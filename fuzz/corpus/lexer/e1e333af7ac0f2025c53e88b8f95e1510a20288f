// Comprehensive Feature Demo
// Tests ALL language features: File I/O, JSON, structs, enums, etc.
// Run with: ./build/agim examples/14_comprehensive_demo.im

import "examples/lib/utils.im"

// === Data Structures ===

struct Config {
    name: string,
    version: string,
    debug: bool
}

enum TaskState {
    Idle,
    Running(string),
    Complete(int),
    Error(string)
}

// === Helper Functions ===

fn state_to_string(s: TaskState) -> string {
    match s {
        Id-> string {
    print("--- " + title + " ---")
    print("")
    return title
}

// === Main Program ===

print_section("AGIM COMPREHENSIVE FEATURE DEMO")

// Range Loops
print_subsection("1. Range Loops")

print("Exclusive range (0..5):")
for i in 0..5 {
    print("  i = " + str(i))
}

print("")
print("Inclusive range (0..=3):")
for i in 0..=3 {
    print("  i = " + str(i))
}

print("")
print("Computed range (0..len(arr)):")
let sample: [int] = [100, 200, 300]
for i in 0..len(sample) {
    print("  arr[" + str(i) + "] = " + str(sample[i]))
}

// Structs and Enums
print_section("2. Structs and Enums")

let config = Config {
    name: "tofu-agent",
    version: "1.0.0",
    debug: true
}
print("Config: name=" + config.name + ", version=" + config.version + ", debug=" + str(config.debug))

print("")
print("Task states:")
let states: [TaskState] = [
    TaskState::Idle,
    TaskState::Running("downloading"),
    TaskState::Complete(0),
    TaskState::Complete(1),
    TaskState::Error("network timeout")
]
for s in states {
    print("  " + state_to_string(s))
}

// Result and Option Types
print_section("3. Result and Option Types")

print_subsection("Result<T, E>")

fn divide(a: int, b: int) -> Result<int, string> {
    if b == 0 {
        return err("division by zero")
    }
    return ok(a / b)
}

let divisions: [[int]] = [[10, 2], [15, 3], [8, 0], [100, 7]]
for d in divisions {
    let a: int = d[0]
    let b: int = d[1]
    let result = divide(a, b)
    match result {
        ok(v) => print("  " + str(a) + " / " + str(b) + " = " + str(v))
        err(e) => print("  " + str(a) + " / " + str(b) + " -> ERROR: " + e)
    }
}

print("")
print_subsection("Option<T>")

fn find_first_positive(arr: [int]) -> Option<int> {
    for n in arr {
        if n > 0 {
            return some(n)
        }
    }
    return none
}

let test_arrays: [[int]] = [
    [-5, -3, 10, 20],
    [-1, -2, -3],
    [0, 0, 5]
]
for arr in test_arrays {
    let result = find_first_positive(arr)
    match result {
        some(v) => print("  " + json.encode(arr) + " -> first positive: " + str(v))
        none => print("  " + json.encode(arr) + " -> no positive found")
    }
}

// File I/O
print_section("4. File I/O")

let test_file = "/tmp/tofu_test.json"
let test_data = Config {
    name: "file-test",
    version: "2.0",
    debug: false
}

print_subsection("fs.write")
let json_content = json.encode({
    "name": test_data.name,
    "version": test_data.version,
    "debug": test_data.debug,
    "items": [1, 2, 3]
})
let write_result = fs.write(test_file, json_content)
match write_result {
    ok(success) => print("  Wrote to " + test_file + ": OK")
    err(e) => print("  Write failed: " + e)
}

print("")
print_subsection("fs.exists")
let exists = fs.exists(test_file)
print("  " + test_file + " exists: " + str(exists))
print("  /nonexistent/file.txt exists: " + str(fs.exists("/nonexistent/file.txt")))

print("")
print_subsection("fs.read")
let read_result = fs.read(test_file)
match read_result {
    ok(content) => {
        print("  Read from " + test_file + ":")
       