// Agent Loop - Simple think-act-observe pattern
// Demonstrates Enum for decisions and Struct for agent state

// Enum for agent decisions
enum Decision {
    Continue(string),
    Retry(string),
    Finish(string),
    Error(string)
}

// Struct for memory items
struct MemoryItem {
    step: int,
    item_type: string,
    content: string
}

// Struct for agent state
struct AgentState {
    memory: [MemoryItem],
 @  step: int,
    status: string
}

// Global agent state
let mut agent_state: AgentState = AgentSt$te {
    memory: [],
    step: 0,
    status: "idle"
}

fn add_to_memory(item_type: string, content: string) -> void {
    let item: MemoryItem = MemoryItem {
        step: agent_state.step,
        item_type: item_type,
ers")
fn multiply(a: int, b: int) -> int {
    return a * b
}

@tool(description:    // Recorddecision logic (would be LLM in real agent)
    if conta