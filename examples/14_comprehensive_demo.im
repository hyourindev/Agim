// Comprehensive Feature Demo
// Tests ALL language features: File I/O, JSON, structs, enums, etc.
// Run with: ./build/agim examples/14_comprehensive_demo.im

import "examples/lib/utils.im"

// === Data Structures ===

struct Config {
    name: string,
    version: string,
    debug: bool
}

enum TaskState {
    Idle,
    Running(string),
    Complete(int),
    Error(string)
}

// === Helper Functions ===

fn state_to_string(s: TaskState) -> string {
    match s {
        Idle => return "IDLE"
        Running(task) => return "RUNNING: " + task
        Complete(code) => {
            if code == 0 {
                return "COMPLETE (success)"
            }
            return "COMPLETE (code " + str(code) + ")"
        }
        Error(msg) => return "ERROR: " + msg
    }
}

fn print_section(title: string) -> string {
    let line = repeat_string("=", 60)
    print("")
    print(line)
    print("  " + title)
    print(line)
    print("")
    return title
}

fn print_subsection(title: string) -> string {
    print("--- " + title + " ---")
    print("")
    return title
}

// === Main Program ===

print_section("AGIM COMPREHENSIVE FEATURE DEMO")

// Range Loops
print_subsection("1. Range Loops")

print("Exclusive range (0..5):")
for i in 0..5 {
    print("  i = " + str(i))
}

print("")
print("Inclusive range (0..=3):")
for i in 0..=3 {
    print("  i = " + str(i))
}

print("")
print("Computed range (0..len(arr)):")
let sample: [int] = [100, 200, 300]
for i in 0..len(sample) {
    print("  arr[" + str(i) + "] = " + str(sample[i]))
}

// Structs and Enums
print_section("2. Structs and Enums")

let config = Config {
    name: "tofu-agent",
    version: "1.0.0",
    debug: true
}
print("Config: name=" + config.name + ", version=" + config.version + ", debug=" + str(config.debug))

print("")
print("Task states:")
let states: [TaskState] = [
    TaskState::Idle,
    TaskState::Running("downloading"),
    TaskState::Complete(0),
    TaskState::Complete(1),
    TaskState::Error("network timeout")
]
for s in states {
    print("  " + state_to_string(s))
}

// Result and Option Types
print_section("3. Result and Option Types")

print_subsection("Result<T, E>")

fn divide(a: int, b: int) -> Result<int, string> {
    if b == 0 {
        return err("division by zero")
    }
    return ok(a / b)
}

let divisions: [[int]] = [[10, 2], [15, 3], [8, 0], [100, 7]]
for d in divisions {
    let a: int = d[0]
    let b: int = d[1]
    let result = divide(a, b)
    match result {
        ok(v) => print("  " + str(a) + " / " + str(b) + " = " + str(v))
        err(e) => print("  " + str(a) + " / " + str(b) + " -> ERROR: " + e)
    }
}

print("")
print_subsection("Option<T>")

fn find_first_positive(arr: [int]) -> Option<int> {
    for n in arr {
        if n > 0 {
            return some(n)
        }
    }
    return none
}

let test_arrays: [[int]] = [
    [-5, -3, 10, 20],
    [-1, -2, -3],
    [0, 0, 5]
]
for arr in test_arrays {
    let result = find_first_positive(arr)
    match result {
        some(v) => print("  " + json.encode(arr) + " -> first positive: " + str(v))
        none => print("  " + json.encode(arr) + " -> no positive found")
    }
}

// File I/O
print_section("4. File I/O")

let test_file = "/tmp/tofu_test.json"
let test_data = Config {
    name: "file-test",
    version: "2.0",
    debug: false
}

print_subsection("fs.write")
let json_content = json.encode({
    "name": test_data.name,
    "version": test_data.version,
    "debug": test_data.debug,
    "items": [1, 2, 3]
})
let write_result = fs.write(test_file, json_content)
match write_result {
    ok(success) => print("  Wrote to " + test_file + ": OK")
    err(e) => print("  Write failed: " + e)
}

print("")
print_subsection("fs.exists")
let exists = fs.exists(test_file)
print("  " + test_file + " exists: " + str(exists))
print("  /nonexistent/file.txt exists: " + str(fs.exists("/nonexistent/file.txt")))

print("")
print_subsection("fs.read")
let read_result = fs.read(test_file)
match read_result {
    ok(content) => {
        print("  Read from " + test_file + ":")
        print("  Content: " + content)
        let parsed = json.parse(content)
        match parsed {
            ok(obj) => print("  Parsed name: " + str(obj["name"]))
            err(e) => print("  Parse error: " + e)
        }
    }
    err(e) => print("  Read failed: " + e)
}

print("")
print_subsection("fs.lines")
// Write a multi-line file first
let lines_file = "/tmp/tofu_lines.txt"
fs.write(lines_file, "Line 1\nLine 2\nLine 3\nLine 4")
let lines_result = fs.lines(lines_file)
match lines_result {
    ok(lines) => {
        print("  Read " + str(len(lines)) + " lines from " + lines_file + ":")
        for i in 0..len(lines) {
            print("    [" + str(i) + "] " + lines[i])
        }
    }
    err(e) => print("  Lines read failed: " + e)
}

// JSON Operations
print_section("5. JSON Operations")

print_subsection("json.encode")
let complex_obj: map<string, any> = {
    "string": "hello",
    "number": 42,
    "float": 3.14,
    "bool": true,
    "null": nil,
    "array": [1, 2, 3],
    "nested": {
        "a": 1,
        "b": 2
    }
}
let encoded = json.encode(complex_obj)
print("  Encoded: " + encoded)

print("")
print_subsection("json.parse")
let json_strings: [string] = [
    "{\"name\": \"test\", \"value\": 123}",
    "[1, 2, 3, 4, 5]",
    "\"just a string\"",
    "invalid json {"
]
for s in json_strings {
    let result = json.parse(s)
    match result {
        ok(data) => print("  '" + s + "' -> OK: " + json.encode(data))
        err(e) => print("  '" + s + "' -> ERROR: " + e)
    }
}

// Imported Utilities
print_section("6. Imported Module Functions")

log_info("Testing imported utilities")
log_error("test", "This is a test error message")

print("")
let emails: [string] = ["valid@example.com", "invalid", "no-domain@"]
for email in emails {
    let result = validate_email(email)
    match result {
        ok(e) => print("  Email '" + email + "': VALID")
        err(msg) => print("  Email '" + email + "': " + msg)
    }
}

print("")
let nums: [int] = [-10, 5, -3, 8, 0, 12]
print("Array: " + json.encode(nums))
print("Sum: " + str(sum_array(nums)))
print("Positive: " + json.encode(filter_positive(nums)))

let idx = find_index(nums, 8)
match idx {
    some(i) => print("Index of 8: " + str(i))
    none => print("8 not found")
}

// Tool Definitions
print_section("7. Tool Definitions")

@tool(description: "Add two numbers together")
fn tool_add(a: int, b: int) -> map<string, any> {
    return {
        "operation": "add",
        "a": a,
        "b": b,
        "result": a + b
    }
}

print("Calling tool_add(10, 32):")
let add_result = tool_add(10, 32)
print("  " + json.encode(add_result))

// Final Summary
print_section("DEMO COMPLETE")

print("All features tested:")
print("  [x] Structs (Config)")
print("  [x] Enums with payloads (TaskState)")
print("  [x] Match expressions (with blocks, returns)")
print("  [x] Result<T, E> (ok/err)")
print("  [x] Option<T> (some/none)")
print("  [x] For loops - exclusive range (0..n)")
print("  [x] For loops - inclusive range (0..=n)")
print("  [x] For loops - computed range (0..len(arr))")
print("  [x] For loops - over arrays")
print("  [x] Module imports")
print("  [x] File I/O - fs.read, fs.write, fs.exists, fs.lines")
print("  [x] JSON - json.encode, json.parse")
print("  [x] Tool definitions (@tool decorator)")
print("  [x] Nested data structures")
print("  [x] Array operations (push, len)")
print("")
print("Note: String interpolation is NOT available - use concatenation with +")
print("")
