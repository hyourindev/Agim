// Comprehensive Feature Demo
// Tests ALL language features: HTTP methods, WebSockets, File I/O, JSON, structs, enums, etc.
// Run with: ./build/agim examples/14_comprehensive_demo.im

import "examples/lib/utils.im"

// === Data Structures ===

struct Config {
    name: string,
    version: string,
    debug: bool
}

struct HttpResult {
    method: string,
    url: string,
    success: bool,
    status: string
}

enum TaskState {
    Idle,
    Running(string),
    Complete(int),
    Error(string)
}

// === Helper Functions ===

fn state_to_string(s: TaskState) -> string {
    match s {
        Idle => return "IDLE"
        Running(task) => return "RUNNING: " + task
        Complete(code) => {
            if code == 0 {
                return "COMPLETE (success)"
            }
            return "COMPLETE (code " + str(code) + ")"
        }
        Error(msg) => return "ERROR: " + msg
    }
}

fn make_http_result(method: string, url: string, success: bool, status: string) -> HttpResult {
    return HttpResult {
        method: method,
        url: url,
        success: success,
        status: status
    }
}

fn print_section(title: string) -> string {
    let line = repeat_string("=", 60)
    print("")
    print(line)
    print("  " + title)
    print(line)
    print("")
    return title
}

fn print_subsection(title: string) -> string {
    print("--- " + title + " ---")
    print("")
    return title
}

// === Main Program ===

print_section("AGIM COMPREHENSIVE FEATURE DEMO")

// Range Loops
print_subsection("1. Range Loops")

print("Exclusive range (0..5):")
for i in 0..5 {
    print("  i = " + str(i))
}

print("")
print("Inclusive range (0..=3):")
for i in 0..=3 {
    print("  i = " + str(i))
}

print("")
print("Computed range (0..len(arr)):")
let sample: [int] = [100, 200, 300]
for i in 0..len(sample) {
    print("  arr[" + str(i) + "] = " + str(sample[i]))
}

// Structs and Enums
print_section("2. Structs and Enums")

let config = Config {
    name: "tofu-agent",
    version: "1.0.0",
    debug: true
}
print("Config: name=" + config.name + ", version=" + config.version + ", debug=" + str(config.debug))

print("")
print("Task states:")
let states: [TaskState] = [
    TaskState::Idle,
    TaskState::Running("downloading"),
    TaskState::Complete(0),
    TaskState::Complete(1),
    TaskState::Error("network timeout")
]
for s in states {
    print("  " + state_to_string(s))
}

// Result and Option Types
print_section("3. Result and Option Types")

print_subsection("Result<T, E>")

fn divide(a: int, b: int) -> Result<int, string> {
    if b == 0 {
        return err("division by zero")
    }
    return ok(a / b)
}

let divisions: [[int]] = [[10, 2], [15, 3], [8, 0], [100, 7]]
for d in divisions {
    let a: int = d[0]
    let b: int = d[1]
    let result = divide(a, b)
    match result {
        ok(v) => print("  " + str(a) + " / " + str(b) + " = " + str(v))
        err(e) => print("  " + str(a) + " / " + str(b) + " -> ERROR: " + e)
    }
}

print("")
print_subsection("Option<T>")

fn find_first_positive(arr: [int]) -> Option<int> {
    for n in arr {
        if n > 0 {
            return some(n)
        }
    }
    return none
}

let test_arrays: [[int]] = [
    [-5, -3, 10, 20],
    [-1, -2, -3],
    [0, 0, 5]
]
for arr in test_arrays {
    let result = find_first_positive(arr)
    match result {
        some(v) => print("  " + json.encode(arr) + " -> first positive: " + str(v))
        none => print("  " + json.encode(arr) + " -> no positive found")
    }
}

// File I/O
print_section("4. File I/O")

let test_file = "/tmp/tofu_test.json"
let test_data = Config {
    name: "file-test",
    version: "2.0",
    debug: false
}

print_subsection("fs.write")
let json_content = json.encode({
    "name": test_data.name,
    "version": test_data.version,
    "debug": test_data.debug,
    "items": [1, 2, 3]
})
let write_result = fs.write(test_file, json_content)
match write_result {
    ok(success) => print("  Wrote to " + test_file + ": OK")
    err(e) => print("  Write failed: " + e)
}

print("")
print_subsection("fs.exists")
let exists = fs.exists(test_file)
print("  " + test_file + " exists: " + str(exists))
print("  /nonexistent/file.txt exists: " + str(fs.exists("/nonexistent/file.txt")))

print("")
print_subsection("fs.read")
let read_result = fs.read(test_file)
match read_result {
    ok(content) => {
        print("  Read from " + test_file + ":")
        print("  Content: " + content)
        let parsed = json.parse(content)
        match parsed {
            ok(obj) => print("  Parsed name: " + str(obj["name"]))
            err(e) => print("  Parse error: " + e)
        }
    }
    err(e) => print("  Read failed: " + e)
}

print("")
print_subsection("fs.lines")
// Write a multi-line file first
let lines_file = "/tmp/tofu_lines.txt"
fs.write(lines_file, "Line 1\nLine 2\nLine 3\nLine 4")
let lines_result = fs.lines(lines_file)
match lines_result {
    ok(lines) => {
        print("  Read " + str(len(lines)) + " lines from " + lines_file + ":")
        for i in 0..len(lines) {
            print("    [" + str(i) + "] " + lines[i])
        }
    }
    err(e) => print("  Lines read failed: " + e)
}

// HTTP Methods
print_section("5. HTTP Methods")

let base_url = "https://httpbin.org"
let http_results: [HttpResult] = []

print_subsection("http.get")
let get_result = http.get(base_url + "/get")
match get_result {
    ok(body) => {
        push(http_results, make_http_result("GET", "/get", true, "200 OK"))
        let parsed = json.parse(body)
        match parsed {
            ok(data) => print("  GET /get -> origin: " + str(data["origin"]))
            err(e) => print("  GET /get -> parse error")
        }
    }
    err(e) => {
        push(http_results, make_http_result("GET", "/get", false, e))
        print("  GET /get -> error: " + e)
    }
}

print("")
print_subsection("http.post")
let post_body = json.encode({"message": "hello from tofu", "count": 42})
let post_result = http.post(base_url + "/post", post_body)
match post_result {
    ok(body) => {
        push(http_results, make_http_result("POST", "/post", true, "200 OK"))
        let parsed = json.parse(body)
        match parsed {
            ok(data) => print("  POST /post -> echoed data received")
            err(e) => print("  POST /post -> parse error")
        }
    }
    err(e) => {
        push(http_results, make_http_result("POST", "/post", false, e))
        print("  POST /post -> error: " + e)
    }
}

print("")
print_subsection("http.put")
let put_body = json.encode({"update": "new value"})
let put_result = http.put(base_url + "/put", put_body)
match put_result {
    ok(body) => {
        push(http_results, make_http_result("PUT", "/put", true, "200 OK"))
        print("  PUT /put -> success")
    }
    err(e) => {
        push(http_results, make_http_result("PUT", "/put", false, e))
        print("  PUT /put -> error: " + e)
    }
}

print("")
print_subsection("http.patch")
let patch_body = json.encode({"patch": "partial update"})
let patch_result = http.patch(base_url + "/patch", patch_body)
match patch_result {
    ok(body) => {
        push(http_results, make_http_result("PATCH", "/patch", true, "200 OK"))
        print("  PATCH /patch -> success")
    }
    err(e) => {
        push(http_results, make_http_result("PATCH", "/patch", false, e))
        print("  PATCH /patch -> error: " + e)
    }
}

print("")
print_subsection("http.delete")
let delete_result = http.delete(base_url + "/delete")
match delete_result {
    ok(body) => {
        push(http_results, make_http_result("DELETE", "/delete", true, "200 OK"))
        print("  DELETE /delete -> success")
    }
    err(e) => {
        push(http_results, make_http_result("DELETE", "/delete", false, e))
        print("  DELETE /delete -> error: " + e)
    }
}

print("")
print_subsection("http.request (custom headers)")
let custom_headers: map<string, string> = {
    "X-Custom-Header": "tofu-value",
    "Accept": "application/json"
}
let request_result = http.request("GET", base_url + "/headers", "", custom_headers)
match request_result {
    ok(body) => {
        push(http_results, make_http_result("REQUEST", "/headers", true, "200 OK"))
        let parsed = json.parse(body)
        match parsed {
            ok(data) => {
                let headers = data["headers"]
                print("  Custom header echoed: X-Custom-Header present")
            }
            err(e) => print("  REQUEST /headers -> parse error")
        }
    }
    err(e) => {
        push(http_results, make_http_result("REQUEST", "/headers", false, e))
        print("  REQUEST /headers -> error: " + e)
    }
}

print("")
print("HTTP Results Summary:")
for r in http_results {
    let status_str = "FAIL"
    if r.success {
        status_str = "OK"
    }
    print("  " + r.method + " " + r.url + " -> " + status_str)
}

// WebSocket
print_section("6. WebSocket")

// Note: ws.connect returns handle or nil, ws.send returns bool, ws.recv returns string or nil
print("Connecting to wss://echo.websocket.org...")
let ws_handle = ws.connect("wss://echo.websocket.org")

if ws_handle == nil {
    print("  Connection failed (server may be unavailable)")
} else {
    print("  Connected!")

    // Send a message
    let ws_message = "Hello from Agim!"
    print("  Sending: " + ws_message)
    let send_ok: bool = ws.send(ws_handle, ws_message)
    print("  Send result: " + str(send_ok))

    // Try to receive echo (with timeout)
    print("  Receiving with 3s timeout...")
    let recv_msg = ws.recv(ws_handle, 3000)
    if recv_msg == nil {
        print("  No response (timeout or error)")
    } else {
        print("  Received: " + recv_msg)
    }

    // Close connection
    ws.close(ws_handle)
    print("  WebSocket closed")
}

// JSON Operations
print_section("7. JSON Operations")

print_subsection("json.encode")
let complex_obj: map<string, any> = {
    "string": "hello",
    "number": 42,
    "float": 3.14,
    "bool": true,
    "null": nil,
    "array": [1, 2, 3],
    "nested": {
        "a": 1,
        "b": 2
    }
}
let encoded = json.encode(complex_obj)
print("  Encoded: " + encoded)

print("")
print_subsection("json.parse")
let json_strings: [string] = [
    "{\"name\": \"test\", \"value\": 123}",
    "[1, 2, 3, 4, 5]",
    "\"just a string\"",
    "invalid json {"
]
for s in json_strings {
    let result = json.parse(s)
    match result {
        ok(data) => print("  '" + s + "' -> OK: " + json.encode(data))
        err(e) => print("  '" + s + "' -> ERROR: " + e)
    }
}

// Imported Utilities
print_section("8. Imported Module Functions")

log_info("Testing imported utilities")
log_error("test", "This is a test error message")

print("")
let emails: [string] = ["valid@example.com", "invalid", "no-domain@"]
for email in emails {
    let result = validate_email(email)
    match result {
        ok(e) => print("  Email '" + email + "': VALID")
        err(msg) => print("  Email '" + email + "': " + msg)
    }
}

print("")
let nums: [int] = [-10, 5, -3, 8, 0, 12]
print("Array: " + json.encode(nums))
print("Sum: " + str(sum_array(nums)))
print("Positive: " + json.encode(filter_positive(nums)))

let idx = find_index(nums, 8)
match idx {
    some(i) => print("Index of 8: " + str(i))
    none => print("8 not found")
}

// Tool Definitions
print_section("9. Tool Definitions")

@tool(description: "Add two numbers together")
fn tool_add(a: int, b: int) -> map<string, any> {
    return {
        "operation": "add",
        "a": a,
        "b": b,
        "result": a + b
    }
}

@tool(description: "Fetch and summarize a URL")
fn tool_fetch_summary(url: string) -> map<string, any> {
    let result = http.get(url)
    match result {
        ok(body) => {
            return {
                "success": true,
                "url": url,
                "length": len(body),
                "preview": "..." // Would truncate body in real impl
            }
        }
        err(e) => {
            return {
                "success": false,
                "url": url,
                "error": e
            }
        }
    }
}

print("Calling tool_add(10, 32):")
let add_result = tool_add(10, 32)
print("  " + json.encode(add_result))

print("")
print("Calling tool_fetch_summary:")
let fetch_result = tool_fetch_summary("https://httpbin.org/uuid")
print("  " + json.encode(fetch_result))

// Final Summary
print_section("DEMO COMPLETE")

print("All features tested:")
print("  [x] Structs (Config, HttpResult)")
print("  [x] Enums with payloads (TaskState)")
print("  [x] Match expressions (with blocks, returns)")
print("  [x] Result<T, E> (ok/err)")
print("  [x] Option<T> (some/none)")
print("  [x] For loops - exclusive range (0..n)")
print("  [x] For loops - inclusive range (0..=n)")
print("  [x] For loops - computed range (0..len(arr))")
print("  [x] For loops - over arrays")
print("  [x] Module imports")
print("  [x] File I/O - fs.read, fs.write, fs.exists, fs.lines")
print("  [x] HTTP - http.get")
print("  [x] HTTP - http.post")
print("  [x] HTTP - http.put")
print("  [x] HTTP - http.patch")
print("  [x] HTTP - http.delete")
print("  [x] HTTP - http.request (custom headers)")
print("  [x] WebSocket - ws.connect, ws.send, ws.recv, ws.close")
print("  [x] JSON - json.encode, json.parse")
print("  [x] Tool definitions (@tool decorator)")
print("  [x] Nested data structures")
print("  [x] Array operations (push, len)")
print("")
print("Note: String interpolation is NOT available - use concatenation with +")
print("")
